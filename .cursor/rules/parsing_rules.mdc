---
description: Правила и паттерны разработки парсеров торговых площадок (PHP + Python)
globs: api/connectors/*.php, backend/app/parsing/**/*.py, api/SiteOrganizationParser.php
alwaysApply: false
---
# Правила разработки парсеров торговых площадок

При работе с парсингом данных (тендеры, закупки) следуй этим правилам для обеспечения надежности, обхода блокировок и поддерживаемости кода.

Подробные технические инструкции по Python-сервису см. в @.cursor/rules/python_parsing_service.mdc.

## 1. Архитектура коннекторов

Используй паттерн **Strategy** для реализации парсеров отдельных площадок.

*   **Базовый класс**: `AbstractConnector` (`api/connectors/AbstractConnector.php`) — содержит общую логику (HTTP-запросы, куки, логирование, взаимодействие с Python-сервисом).
*   **Реализации**: Каждый домен должен иметь свой класс (например, `B2BCenterConnector`).
*   **Фабрика**: `ConnectorFactory` выбирает нужный коннектор по домену.

## 2. Стратегия загрузки страниц (Hybrid Parsing)

Используй двухуровневый подход для оптимизации скорости и обхода защит:

### Уровень 1: PHP cURL (Fast Path)
Всегда начинай с простого HTTP-запроса через `request()`. Это быстро (<1 сек) и дешево.
Используй это для:
*   Простых сайтов без JS-рендеринга.
*   API-эндпоинтов (например, Zakupki.gov.ru API).
*   Первичной проверки доступности страницы.

### Уровень 2: Python Parsing Service (Smart Fallback)
Если cURL вернул ошибку (403/503), капчу или "пустой" JS-код, переключайся на `fetchWithBrowser($url)`.
*   **Механизм**: PHP делает HTTP POST запрос к локальному сервису `http://127.0.0.1:8001/api/parsing/parse`.
*   **Технология**: FastAPI + Playwright (Python) + Stealth Plugin.

#### SPA, Lazy Loading и "Глубокий Парсинг"
Современные площадки (SPA на React/Vue, B2B-Center) требуют сложной обработки:
1.  **Скроллинг**: Страницу необходимо проскроллить, чтобы сработала "ленивая" подгрузка контактов. Python-сервис делает это автоматически.
2.  **Ожидание**: Использовать `wait_for_selector` для ключевых элементов (или `#__NEXT_DATA__` для Next.js).
3.  **Переход по ссылкам (Deep Follow)**: ИНН часто отсутствует на странице тендера и находится только в профиле заказчика.
    *   **Правило**: Если ИНН не найден, но есть ссылка на профиль компании — парсер должен вернуть эту ссылку.
    *   **Логика**: Роутер сервиса автоматически загрузит вторую страницу и извлечет ИНН оттуда.

```php
$html = $this->request($url);
if (!$html || strlen($html) < 5000) {
    // Используем Python сервис с ожиданием элемента React-приложения или данных
    $html = $this->fetchWithBrowser($url, '#__NEXT_DATA__, .organizer-information'); 
}
```

## 3. Парсинг данных (Best Practices)

*   **JSON Injection**: Для сайтов на React/Next.js всегда проверяй наличие данных в `<script id="__NEXT_DATA__" type="application/json">` перед парсингом HTML. Это надежнее.
*   **DOM Context**: Не ищи ИНН регулярками по всему тексту (слишком много ошибок). Ищи строго в блоках "Организатор/Заказчик".
*   **Принцип "Всё или ничего"**: Парсер должен находить ИНН на странице или переходить по ссылкам профиля компании. **НЕ** используй API (DaData) для "угадывания" ИНН, если его нет в источнике.

## 4. Безопасность и Логирование

*   **Debug in Response**: В случае ошибки парсинга, возвращай отладочную информацию (например, "HTML loaded, JSON missing") в одном из текстовых полей (например, `recipient`), чтобы видеть причину в PHP-логах без доступа к консоли сервера.
*   **Credentials**: Логины/пароли хранятся в `api/platform_credentials.php`.

## 5. Тестирование

*   При изменении Python-кода **всегда перезапускай сервис**: `sudo systemctl restart kp-auth-backend.service`.
*   Проверяй логи: `sudo journalctl -u kp-auth-backend.service -f`.
